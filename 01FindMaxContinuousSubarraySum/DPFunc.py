
# -*- coding: utf-8 -*-
"""
最大和连续子数组一定有如下几个特点：
1、第一个不为负数
2、如果前面数的累加值加上当前数后的值会比当前数小，说明累计值对整体和是有害的；如果前面数的累加值加上当前数后的值比当前数大或者等于，则说明累计值对整体和是有益的。
步骤：
1、定义两个变量，一个用来存储之前的累加值，一个用来存储当前的最大和。遍历数组中的每个元素，假设遍历到第i个数时：
①如果前面的累加值为负数或者等于0，那对累加值清0重新累加，把当前的第i个数的值赋给累加值。
②如果前面的累加值为整数，那么继续累加，即之前的累加值加上当前第i个数的值作为新的累加值。
2、判断累加值是否大于最大值：如果大于最大值，则最大和更新；否则，继续保留之前的最大和
它只对数据进行一次扫描，一旦元素被读入并被处理，它就不再需要被记忆。因此，如果数组在磁盘或磁带上，
他就可以被顺序读入，在主存中不必存储数组的任何部分。不仅如此，在任意时刻，
该算法都能对它已经读入的数据给出最大子数组（另外两种算法不具有这种特性）。
具有这种特性的算法叫做联机算法。
"""
def maxSumofSubArray(list):
    if len(list) > 0:
        max_sum = list[0]
        pre_sum = 0
    else:
        max_sum = None
    for i in list:
        if pre_sum <0:
            pre_sum = i
        else:
            pre_sum += i
        if pre_sum > max_sum:
            max_sum = pre_sum
    return max_sum

def main():
    list = [[6,-3,1,-2,7,-15,1,2,2],
           [1, -2, 3, 10, -4, 7, 2, -5],
           [1, 3, 10, -4, 7, 2],
           [-2, -2, -1, -1, -2],
           [-10, -3, -2, -14, 2],
           []]
    for ls in list:
        res = maxSumofSubArray(ls)
        print('max sum of subarray is', res)
if __name__ == '__main__':
    main()
