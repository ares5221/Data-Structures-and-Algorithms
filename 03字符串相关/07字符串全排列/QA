字符串的全排列 给定字符串S[0…N-1]，设计算法，枚举S的全排列。
分为递归与非递归
是否包含重复字符

重复字符的全排列递归算法时间复杂度o((n+1)!)

也可以用空间换时间的方法，用一个空间存储已经替换过的字符，对于后面重复的字符就跳过
 如果是单字符，可以使用mark[256]；
 如果是整数，可以遍历整数得到最大值max和最小值min，使用mark[max-min+1]；
 如果是浮点数或其他结构，考虑使用Hash。
 事实上，如果发现整数间变化太大，也应该考虑使用Hash；
可以认为整数/字符的情况是最朴素的Hash。


非递归的思路
我们从后向前找第一双相邻的递增数字，”21”、”32”、”43”都是非递增的，”24”即满足要求，称前一个数字2为替换数，替换数的下标称为替换点，再从后面找一个比替换数大的最小数（这个数必然存在），1、2都不行，3可以，将3和2交换得到”534221”，然后再将替换点后的字符串”4221”颠倒即得到”531224”。
对于像”543221”这种已经是最“大”的排列，返回false。
这样，一个while循环再加上计算字符串下一个排列的函数就可以实现非递归的全排列算法。
步骤：后找、小大、交换、翻转——
 后找：字符串中最后一个升序的位置i，即：S[k]>S[k+1](k>i)，S[i]<S[i+1]；
 查找(小大)：S[i+1…N-1]中比S[i]大的最小值S[j]；
 交换：S[i]，S[j]；交换操作前和操作后，S[i+1…N-1]一定都是降序的
 翻转：S[i+1…N-1]
 思考：交换操作后，S[i+1…N-1]一定是降序的
 以926520为例，考察该算法的正确性。


 二、字符串的组合
题目：输入一个字符串，输出该字符串中字符的所有组合。举个例子，如果输入abc，
它的组合有a、b、c、ab、ac、bc、abc。
上面我们详细讨论了如何用递归的思路求字符串的排列。同样，本题也可以用递归的思路来求字符串的组合。
假设我们想在长度为n的字符串中求m个字符的组合。我们先从头扫描字符串的第一个字符。
针对第一个字符，我们有两种选择：第一是把这个字符放到组合中去，接下来我们需要在剩下的n-1个字符中选取m-1个字符；
第二是不把这个字符放到组合中去，接下来我们需要在剩下的n-1个字符中选择m个字符。这两种选择都很容易用递归实现。


